{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Zitnik Lab Repository Template","text":"<p>A modern, production-ready template for Python-based research projects in the Zitnik Lab.</p> <ul> <li>Template repository: https://github.com/mims-harvard/template/</li> <li>Documentation https://zitniklab.hms.harvard.edu/template</li> </ul>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>\ud83d\ude80 Fast setup with automated environment configuration and dependency management.</li> <li>\ud83d\udee0\ufe0f Pre-configured tooling including linting, formatting, and testing with pre-commit hooks.</li> <li>\ud83d\udce6 Modern Python packaging using uv for lightning-fast dependency resolution.</li> <li>\ud83d\udd04 CI/CD ready with GitHub Actions for automated testing and deployment.</li> <li>\ud83d\udcdd Documentation ready with automatic documentation generation with MkDocs.</li> <li>\ud83e\uddea Testing framework pre-configured with pytest and coverage reporting.</li> <li>\ud83d\udd27 Development tools including Makefile commands for common tasks.</li> </ul> <p>This template provides everything you need to start a new research project with modern Python best practices built-in.</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<p>Minimal requirements:</p> <ul> <li>GNU Make</li> <li>uv</li> </ul> <p>Optional:</p> <ul> <li>Docker</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li> <p>Create your project by using this template on GitHub or cloning it locally</p> </li> <li> <p>Set up your development environment: <code>bash    make install</code>    This command will:</p> </li> <li>Create a virtual environment</li> <li>Install all dependencies</li> <li>Set up pre-commit hooks</li> <li> <p>Configure development tools</p> </li> <li> <p>Verify everything works: <code>bash    make check</code>    This runs code formatting and linting checks to ensure your setup is correct.</p> </li> <li> <p>Commit your initial setup: <code>bash    git add .    git commit -m \"Initial project setup\"    git push origin main</code></p> </li> </ol> <p>You're now ready to start development! The CI/CD pipeline will automatically run when you open pull requests or push to main.</p>"},{"location":"#setup-for-deployment-and-documentation","title":"Setup for Deployment and Documentation","text":"<ol> <li>Enable documentation deployment:    To set up automatic documentation deployment:</li> <li>Navigate to <code>Settings &gt; Actions &gt; General</code> in your repository</li> <li> <p>Under <code>Workflow permissions</code>, select <code>Read and write permissions</code></p> </li> <li> <p>Create your first release:</p> </li> <li>Go to your repository on GitHub and click <code>Releases</code> on the right sidebar</li> <li>Select <code>Draft a new release</code> (or visit <code>https://github.com/mims-harvard/&lt;repository-name&gt;/releases/new</code>)</li> <li>Give your release a title and add a new tag in the format <code>v1.0.0</code></li> <li> <p>Press <code>Publish release</code></p> </li> <li> <p>Deploy documentation to Lab website</p> </li> <li>Navigate to <code>Settings &gt; Code and Automation &gt; Pages</code></li> <li>You should see: <code>Your site is ready to be published at https://zitniklab.hms.harvard.edu//&lt;repository-name&gt;/</code></li> <li>Under <code>Source</code>, select the branch <code>gh-pages</code></li> </ol>"},{"location":"#development-commands","title":"Development Commands","text":"<p>The template includes convenient Makefile commands for common development tasks. You can see all available commands running <code>make help</code>:</p> <pre><code>$ make\n\nUsage: make &lt;command&gt;\n    help                 List available commands with their descriptions\n    install              Create the virtual environment and install the pre-commit hooks\n    check                Run code quality tools.\n    test                 Test the code with pytest\n    build                Build wheel file\n    clean-build          Clean build artifacts\n    docs-test            Test if documentation can be built without warnings or errors\n    docs                 Build and serve the documentation\n    clean                Clean up the project\n    jupyterlab           Spin up JupyterLab\n</code></pre>"},{"location":"#support","title":"Support","text":"<p>For questions about using this template or contributing improvements, please open an issue in the GitHub repository.</p>"},{"location":"#license","title":"License","text":"<p>This template is released under the MIT License.</p>"},{"location":"reference/","title":"Reference","text":"<p>               Bases: <code>RichHandler</code></p> <p>Enhanced Rich logging handler with support for colored formatting and traceback customization.</p> <p>This handler extends Rich's built-in handler to provide enhanced logging capabilities.</p> Features <ul> <li>Automatic warning capture: Captures and formats Python warnings as log messages</li> <li>Pretty printing: Formats complex Python objects in a readable way</li> <li>Customizable traceback handling: Configure how stack traces are displayed</li> <li>Colored log formatting: Supports Rich markup for colorful, styled output</li> </ul> Note <p>This handler automatically enables warning capture and pretty printing on initialization. Traceback handling can be customized through constructor arguments prefixed with <code>tracebacks_</code>.</p> Source code in <code>src/cli/__init__.py</code> <pre><code>class RichHandler(rich.logging.RichHandler):\n    \"\"\"Enhanced Rich logging handler with support for colored formatting and traceback customization.\n\n    This handler extends Rich's built-in handler to provide enhanced logging capabilities.\n\n    Features:\n        - Automatic warning capture: Captures and formats Python warnings as log messages\n        - Pretty printing: Formats complex Python objects in a readable way\n        - Customizable traceback handling: Configure how stack traces are displayed\n        - Colored log formatting: Supports Rich markup for colorful, styled output\n\n    Note:\n        This handler automatically enables warning capture and pretty printing on initialization.\n        Traceback handling can be customized through constructor arguments prefixed with `tracebacks_`.\n    \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"Initialize the RichHandler with enhanced functionality.\n\n        Args:\n            *args: Positional arguments passed to RichHandler\n            **kwargs: Keyword arguments including:\n                - markup: Enable Rich markup (defaults to True)\n                - tracebacks_*: Customization options for traceback handling\n        \"\"\"\n        # Ensure markup is enabled by default\n        kwargs.setdefault(\"markup\", True)\n        super().__init__(*args, **kwargs)\n\n        # Enable warning capture and pretty printing\n        captureWarnings(True)\n        pretty.install()\n\n        # Suppress tracebacks for click\n        traceback_install_kwargs = {\"suppress\": [click, str(Path(sys.executable).parent)]}\n        self._configure_traceback_kwargs(kwargs, traceback_install_kwargs)\n\n        if self.rich_tracebacks:\n            traceback.install(**traceback_install_kwargs)\n\n    def _configure_traceback_kwargs(self, input_kwargs: dict, traceback_kwargs: dict) -&gt; None:\n        \"\"\"Process traceback-related configuration from input kwargs.\n\n        Args:\n            input_kwargs: Input keyword arguments\n            traceback_kwargs: Dict to store processed traceback configuration\n        \"\"\"\n        prefix = \"tracebacks_\"\n        for key, value in input_kwargs.items():\n            if key.startswith(prefix):\n                key_without_prefix = key[len(prefix) :]\n                if key_without_prefix == \"suppress\":\n                    traceback_kwargs[key_without_prefix].extend(value)\n                else:\n                    traceback_kwargs[key_without_prefix] = value\n\n    def emit(self, record: LogRecord) -&gt; None:\n        \"\"\"Emit a log record with optional Rich formatting.\n\n        Args:\n            record: The LogRecord to emit\n\n        Raises:\n            TypeError: If rich_format is specified but is not a non-empty list\n        \"\"\"\n        if not record.args or not hasattr(record, \"rich_format\"):\n            return super().emit(record)\n\n        updated_record = copy.copy(record)\n        format_args = record.rich_format\n\n        if not isinstance(format_args, list) or not format_args:\n            raise TypeError(\"rich_format must be a non-empty list\")\n\n        # Apply Rich color formatting to arguments\n        new_args = [f\"[{color}]{arg}[/{color}]\" for arg, color in zip(record.args, format_args)]\n        updated_record.args = tuple(new_args)\n        super().emit(updated_record)\n</code></pre>"},{"location":"reference/#cli.RichHandler.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize the RichHandler with enhanced functionality.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Positional arguments passed to RichHandler</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments including: - markup: Enable Rich markup (defaults to True) - tracebacks_*: Customization options for traceback handling</p> <code>{}</code> Source code in <code>src/cli/__init__.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize the RichHandler with enhanced functionality.\n\n    Args:\n        *args: Positional arguments passed to RichHandler\n        **kwargs: Keyword arguments including:\n            - markup: Enable Rich markup (defaults to True)\n            - tracebacks_*: Customization options for traceback handling\n    \"\"\"\n    # Ensure markup is enabled by default\n    kwargs.setdefault(\"markup\", True)\n    super().__init__(*args, **kwargs)\n\n    # Enable warning capture and pretty printing\n    captureWarnings(True)\n    pretty.install()\n\n    # Suppress tracebacks for click\n    traceback_install_kwargs = {\"suppress\": [click, str(Path(sys.executable).parent)]}\n    self._configure_traceback_kwargs(kwargs, traceback_install_kwargs)\n\n    if self.rich_tracebacks:\n        traceback.install(**traceback_install_kwargs)\n</code></pre>"},{"location":"reference/#cli.RichHandler.emit","title":"<code>emit(record)</code>","text":"<p>Emit a log record with optional Rich formatting.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>The LogRecord to emit</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If rich_format is specified but is not a non-empty list</p> Source code in <code>src/cli/__init__.py</code> <pre><code>def emit(self, record: LogRecord) -&gt; None:\n    \"\"\"Emit a log record with optional Rich formatting.\n\n    Args:\n        record: The LogRecord to emit\n\n    Raises:\n        TypeError: If rich_format is specified but is not a non-empty list\n    \"\"\"\n    if not record.args or not hasattr(record, \"rich_format\"):\n        return super().emit(record)\n\n    updated_record = copy.copy(record)\n    format_args = record.rich_format\n\n    if not isinstance(format_args, list) or not format_args:\n        raise TypeError(\"rich_format must be a non-empty list\")\n\n    # Apply Rich color formatting to arguments\n    new_args = [f\"[{color}]{arg}[/{color}]\" for arg, color in zip(record.args, format_args)]\n    updated_record.args = tuple(new_args)\n    super().emit(updated_record)\n</code></pre>"}]}